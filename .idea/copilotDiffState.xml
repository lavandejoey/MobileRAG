<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/apps/chat_ui/src/App.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/chat_ui/src/App.jsx" />
              <option name="originalContent" value="// -*- coding: utf-8 -*-&#10;/**&#10; * @author: LIU Ziyi&#10; * @email: lavandejoey@outlook.com&#10; * @date: 2025/08/15&#10; * @version: 0.12.0&#10; */&#10;import React, { useState, useEffect, useRef } from 'react';&#10;import './App.css';&#10;&#10;function App() {&#10;  const [messages, setMessages] = useState([]);&#10;  const [input, setInput] = useState('');&#10;  const [sessionId, setSessionId] = useState('test_session'); // Default session ID&#10;  const [evidenceList, setEvidenceList] = useState([]);&#10;  const [memoryList, setMemoryList] = useState([]);&#10;  const [isGenerating, setIsGenerating] = useState(false); // New state for generation status&#10;  const [backendStatus, setBackendStatus] = useState('checking'); // 'online', 'offline', 'checking'&#10;  const messagesEndRef = useRef(null);&#10;&#10;  const scrollToBottom = () =&gt; {&#10;    messagesEndRef.current?.scrollIntoView({ behavior: &quot;smooth&quot; });&#10;  };&#10;&#10;  // Effect to scroll to bottom on new messages&#10;  useEffect(() =&gt; {&#10;    scrollToBottom();&#10;  }, [messages]);&#10;&#10;  // Effect to check backend status periodically&#10;  useEffect(() =&gt; {&#10;    const checkStatus = async () =&gt; {&#10;      try {&#10;        const response = await fetch('/api/status');&#10;        if (response.ok) {&#10;          const data = await response.json();&#10;          setBackendStatus(data.status === 'online' ? 'online' : 'offline');&#10;        } else {&#10;          setBackendStatus('offline');&#10;        }&#10;      } catch (error) {&#10;        setBackendStatus('offline');&#10;      }&#10;    };&#10;&#10;    checkStatus(); // Check immediately on mount&#10;    const intervalId = setInterval(checkStatus, 5000); // Check every 5 seconds&#10;&#10;    return () =&gt; clearInterval(intervalId); // Cleanup on unmount&#10;  }, []);&#10;&#10;  const handleSendMessage = async (e) =&gt; {&#10;    e.preventDefault();&#10;    if (input.trim() === '') return;&#10;&#10;    const userMessage = { sender: 'user', text: input };&#10;    setMessages((prevMessages) =&gt; [...prevMessages, userMessage]);&#10;    setInput('');&#10;    setEvidenceList([]); // Clear previous evidence&#10;    setIsGenerating(true); // Set generating status to true&#10;&#10;    let currentAssistantMessage = '';&#10;    const updateAssistantMessage = (text) =&gt; {&#10;      setMessages((prevMessages) =&gt; {&#10;        const lastMessage = prevMessages[prevMessages.length - 1];&#10;        if (lastMessage &amp;&amp; lastMessage.sender === 'assistant') {&#10;          return [...prevMessages.slice(0, -1), { ...lastMessage, text: text }];&#10;        } else {&#10;          return [...prevMessages, { sender: 'assistant', text: text }];&#10;        }&#10;      });&#10;    };&#10;&#10;    try {&#10;      const response = await fetch('/api/chat', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;        },&#10;        body: JSON.stringify({ query: input, session_id: sessionId }),&#10;      });&#10;&#10;      const reader = response.body.getReader();&#10;      const decoder = new TextDecoder();&#10;&#10;      while (true) {&#10;        const { done, value } = await reader.read();&#10;        if (done) break;&#10;        const chunk = decoder.decode(value, { stream: true });&#10;        &#10;        // Process each line as a separate SSE event&#10;        chunk.split('\n').forEach(line =&gt; {&#10;          if (line.startsWith('data:')) {&#10;            const jsonString = line.substring(5).trim();&#10;            if (jsonString) {&#10;              try {&#10;                const data = JSON.parse(jsonString);&#10;                if (data.answer) {&#10;                  currentAssistantMessage += data.answer;&#10;                  updateAssistantMessage(currentAssistantMessage);&#10;                } else if (data.evidence) {&#10;                  setEvidenceList(prev =&gt; [...prev, data.evidence]);&#10;                } else if (data.memory) {&#10;                  setMemoryList(prev =&gt; [...prev, data.memory]);&#10;                }&#10;              } catch (error) {&#10;                console.error(&quot;Error parsing SSE JSON:&quot;, error, &quot;JSON string:&quot;, jsonString);&#10;              }&#10;            }&#10;          }&#10;        });&#10;      }&#10;    } catch (error) {&#10;      console.error('Error sending message:', error);&#10;      updateAssistantMessage('Error: Could not connect to the server.');&#10;    } finally {&#10;      setIsGenerating(false); // Set generating status to false when done or error&#10;    }&#10;  };&#10;&#10;  const getStatusColor = () =&gt; {&#10;    switch (backendStatus) {&#10;      case 'online': return 'green';&#10;      case 'offline': return 'red';&#10;      case 'checking': return 'orange';&#10;      default: return 'gray';&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;App&quot;&gt;&#10;      &lt;header className=&quot;App-header&quot;&gt;&#10;        &lt;h1&gt;MobileRAG&lt;/h1&gt;&#10;        &lt;div className=&quot;backend-status&quot;&gt;&#10;          &lt;span style={{ color: getStatusColor() }}&gt;●&lt;/span&gt; {backendStatus}&#10;        &lt;/div&gt;&#10;      &lt;/header&gt;&#10;      &lt;div className=&quot;chat-main&quot;&gt;&#10;        &lt;div className=&quot;chat-container&quot;&gt;&#10;          &lt;div className=&quot;messages-display&quot;&gt;&#10;            {messages.map((msg, index) =&gt; (&#10;              &lt;div key={index} className={`message ${msg.sender}`}&gt;&#10;                {msg.text}&#10;              &lt;/div&gt;&#10;            ))}&#10;            {isGenerating &amp;&amp; (&#10;              &lt;div className=&quot;message assistant generating&quot;&gt;&#10;                Thinking &lt;div className=&quot;spinner&quot;&gt;&lt;/div&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;            &lt;div ref={messagesEndRef} /&gt;&#10;          &lt;/div&gt;&#10;          &lt;form onSubmit={handleSendMessage} className=&quot;message-input-form&quot;&gt;&#10;            &lt;input&#10;              type=&quot;text&quot;&#10;              value={input}&#10;              onChange={(e) =&gt; setInput(e.target.value)}&#10;              placeholder=&quot;Type your message...&quot;&#10;              disabled={isGenerating}&#10;            /&gt;&#10;            &lt;button type=&quot;submit&quot; disabled={!input.trim() || isGenerating}&gt;Send&lt;/button&gt;&#10;          &lt;/form&gt;&#10;        &lt;/div&gt;&#10;        &lt;div className=&quot;sidebar&quot;&gt;&#10;          &lt;h2&gt;Evidence&lt;/h2&gt;&#10;          {evidenceList.length === 0 ? (&#10;            &lt;p&gt;No evidence found for this query.&lt;/p&gt;&#10;          ) : (&#10;            &lt;ul&gt;&#10;              {evidenceList.map((ev, index) =&gt; (&#10;                &lt;li key={index}&gt;{JSON.stringify(ev)}&lt;/li&gt; // Display raw JSON for now&#10;              ))}&#10;            &lt;/ul&gt;&#10;          )}&#10;          &lt;h2&gt;Memory&lt;/h2&gt;&#10;          {memoryList.length === 0 ? (&#10;            &lt;p&gt;No memory items found.&lt;/p&gt;&#10;          ) : (&#10;            &lt;ul&gt;&#10;              {memoryList.map((mem, index) =&gt; (&#10;                &lt;li key={index}&gt;{JSON.stringify(mem)}&lt;/li&gt; // Display raw JSON for now&#10;                            ))}&#10;            &lt;/ul&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default App;&#10;" />
              <option name="updatedContent" value="// -*- coding: utf-8 -*-&#10;/**&#10; * @author: LIU Ziyi&#10; * @email: lavandejoey@outlook.com&#10; * @date: 2025/08/15&#10; * @version: 0.12.0&#10; */&#10;import React, { useState, useEffect, useRef } from 'react';&#10;import './App.css';&#10;&#10;function App() {&#10;  const [messages, setMessages] = useState([]);&#10;  const [input, setInput] = useState('');&#10;  const [sessionId, setSessionId] = useState('test_session'); // Default session ID&#10;  const [evidenceList, setEvidenceList] = useState([]);&#10;  const [memoryList, setMemoryList] = useState([]);&#10;  const [isGenerating, setIsGenerating] = useState(false); // New state for generation status&#10;  const [backendStatus, setBackendStatus] = useState('checking'); // 'online', 'offline', 'checking'&#10;  const messagesEndRef = useRef(null);&#10;&#10;  const scrollToBottom = () =&gt; {&#10;    messagesEndRef.current?.scrollIntoView({ behavior: &quot;smooth&quot; });&#10;  };&#10;&#10;  // Effect to scroll to bottom on new messages&#10;  useEffect(() =&gt; {&#10;    scrollToBottom();&#10;  }, [messages]);&#10;&#10;  // Effect to check backend status periodically&#10;  useEffect(() =&gt; {&#10;    const checkStatus = async () =&gt; {&#10;      try {&#10;        const response = await fetch('/api/status');&#10;        if (response.ok) {&#10;          const data = await response.json();&#10;          setBackendStatus(data.status === 'online' ? 'online' : 'offline');&#10;        } else {&#10;          setBackendStatus('offline');&#10;        }&#10;      } catch (error) {&#10;        setBackendStatus('offline');&#10;      }&#10;    };&#10;&#10;    checkStatus(); // Check immediately on mount&#10;    const intervalId = setInterval(checkStatus, 5000); // Check every 5 seconds&#10;&#10;    return () =&gt; clearInterval(intervalId); // Cleanup on unmount&#10;  }, []);&#10;&#10;  const handleSendMessage = async (e) =&gt; {&#10;    e.preventDefault();&#10;    if (input.trim() === '') return;&#10;&#10;    const userMessage = { sender: 'user', text: input };&#10;    setMessages((prevMessages) =&gt; [...prevMessages, userMessage]);&#10;    setInput('');&#10;    setEvidenceList([]); // Clear previous evidence&#10;    setIsGenerating(true); // Set generating status to true&#10;&#10;    let currentAssistantMessage = '';&#10;    const updateAssistantMessage = (text) =&gt; {&#10;      setMessages((prevMessages) =&gt; {&#10;        const lastMessage = prevMessages[prevMessages.length - 1];&#10;        if (lastMessage &amp;&amp; lastMessage.sender === 'assistant') {&#10;          return [...prevMessages.slice(0, -1), { ...lastMessage, text: text }];&#10;        } else {&#10;          return [...prevMessages, { sender: 'assistant', text: text }];&#10;        }&#10;      });&#10;    };&#10;&#10;    try {&#10;      const response = await fetch('/api/chat', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;        },&#10;        body: JSON.stringify({ query: input, session_id: sessionId }),&#10;      });&#10;&#10;      const reader = response.body.getReader();&#10;      const decoder = new TextDecoder();&#10;&#10;      while (true) {&#10;        const { done, value } = await reader.read();&#10;        if (done) break;&#10;        const chunk = decoder.decode(value, { stream: true });&#10;        &#10;        // Process each line as a separate SSE event&#10;        chunk.split('\n').forEach(line =&gt; {&#10;          if (line.startsWith('data:')) {&#10;            const jsonString = line.substring(5).trim();&#10;            if (jsonString) {&#10;              try {&#10;                const data = JSON.parse(jsonString);&#10;                if (data.answer) {&#10;                  currentAssistantMessage += data.answer;&#10;                  updateAssistantMessage(currentAssistantMessage);&#10;                } else if (data.evidence) {&#10;                  setEvidenceList(prev =&gt; [...prev, data.evidence]);&#10;                } else if (data.memory) {&#10;                  setMemoryList(prev =&gt; [...prev, data.memory]);&#10;                }&#10;              } catch (error) {&#10;                console.error(&quot;Error parsing SSE JSON:&quot;, error, &quot;JSON string:&quot;, jsonString);&#10;              }&#10;            }&#10;          }&#10;        });&#10;      }&#10;    } catch (error) {&#10;      console.error('Error sending message:', error);&#10;      updateAssistantMessage('Error: Could not connect to the server.');&#10;    } finally {&#10;      setIsGenerating(false); // Set generating status to false when done or error&#10;    }&#10;  };&#10;&#10;  const getStatusColor = () =&gt; {&#10;    switch (backendStatus) {&#10;      case 'online': return 'green';&#10;      case 'offline': return 'red';&#10;      case 'checking': return 'orange';&#10;      default: return 'gray';&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;App&quot;&gt;&#10;      &lt;header className=&quot;App-header&quot;&gt;&#10;        &lt;h1&gt;MobileRAG&lt;/h1&gt;&#10;        &lt;div className=&quot;backend-status&quot;&gt;&#10;          &lt;span style={{ color: getStatusColor() }}&gt;●&lt;/span&gt; {backendStatus}&#10;        &lt;/div&gt;&#10;      &lt;/header&gt;&#10;      &lt;div className=&quot;chat-main&quot;&gt;&#10;        &lt;div className=&quot;chat-container&quot;&gt;&#10;          &lt;div className=&quot;messages-display&quot;&gt;&#10;            {messages.map((msg, index) =&gt; (&#10;              &lt;div key={index} className={`message ${msg.sender}`}&gt;&#10;                {msg.text}&#10;              &lt;/div&gt;&#10;            ))}&#10;            {isGenerating &amp;&amp; (&#10;              &lt;div className=&quot;generating-spinner-container&quot;&gt;&#10;                &lt;div className=&quot;spinner&quot;&gt;&lt;/div&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;            &lt;div ref={messagesEndRef} /&gt;&#10;          &lt;/div&gt;&#10;          &lt;form onSubmit={handleSendMessage} className=&quot;message-input-form&quot;&gt;&#10;            &lt;input&#10;              type=&quot;text&quot;&#10;              value={input}&#10;              onChange={(e) =&gt; setInput(e.target.value)}&#10;              placeholder=&quot;Type your message...&quot;&#10;              disabled={isGenerating}&#10;            /&gt;&#10;            &lt;button type=&quot;submit&quot; disabled={!input.trim() || isGenerating}&gt;Send&lt;/button&gt;&#10;          &lt;/form&gt;&#10;        &lt;/div&gt;&#10;        &lt;div className=&quot;sidebar&quot;&gt;&#10;          &lt;h2&gt;Evidence&lt;/h2&gt;&#10;          {evidenceList.length === 0 ? (&#10;            &lt;p&gt;No evidence found for this query.&lt;/p&gt;&#10;          ) : (&#10;            &lt;ul&gt;&#10;              {evidenceList.map((ev, index) =&gt; (&#10;                &lt;li key={index}&gt;{JSON.stringify(ev)}&lt;/li&gt; // Display raw JSON for now&#10;              ))}&#10;            &lt;/ul&gt;&#10;          )}&#10;          &lt;h2&gt;Memory&lt;/h2&gt;&#10;          {memoryList.length === 0 ? (&#10;            &lt;p&gt;No memory items found.&lt;/p&gt;&#10;          ) : (&#10;            &lt;ul&gt;&#10;              {memoryList.map((mem, index) =&gt; (&#10;                &lt;li key={index}&gt;{JSON.stringify(mem)}&lt;/li&gt; // Display raw JSON for now&#10;                            ))}&#10;            &lt;/ul&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default App;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/parse_courses_html.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/parse_courses_html.py" />
              <option name="updatedContent" value="import re&#10;import csv&#10;import os&#10;&#10;def parse_html_file(input_path):&#10;    with open(input_path, 'r', encoding='utf-8') as f:&#10;        data = f.read()&#10;    # Remove HTML comment markers to include commented program lists&#10;    data = re.sub(r'&lt;!--|--&gt;', '', data)&#10;    # Pattern to capture each course section starting at &lt;h3&gt; until next &lt;h3&gt; or end&#10;    section_pattern = re.compile(r'&lt;h3 id=&quot;(?P&lt;id&gt;[^&quot;]+)&quot;&gt;(?P&lt;title&gt;.*?)&lt;/h3&gt;(?P&lt;rest&gt;.*?)(?=(&lt;h3|$))', re.DOTALL)&#10;    records = []&#10;    for match in section_pattern.finditer(data):&#10;        title = match.group('title').strip()&#10;        # Extract course full name and code from title&#10;        if title.endswith(')') and '(' in title:&#10;            name_part, code_part = title.rsplit('(', 1)&#10;            course_name = name_part.strip()&#10;            course_code = code_part.rstrip(')').strip()&#10;        else:&#10;            course_name = title&#10;            course_code = ''&#10;        # Find all &lt;li&gt; elements in the rest of the section&#10;        rest = match.group('rest')&#10;        li_pattern = re.compile(r'&lt;li&gt;(.*?)&lt;/li&gt;', re.DOTALL)&#10;        dates_list = [item.strip() for item in li_pattern.findall(rest)]&#10;        records.append({&#10;            'course full name': course_name,&#10;            'course code': course_code,&#10;            'course dates': dates_list&#10;        })&#10;    return records&#10;&#10;&#10;def write_csv(records, output_path):&#10;    # Ensure output directory exists&#10;    os.makedirs(os.path.dirname(output_path), exist_ok=True)&#10;    with open(output_path, 'w', newline='', encoding='utf-8') as csvfile:&#10;        writer = csv.writer(csvfile)&#10;        # Header row&#10;        writer.writerow(['course full name', 'course code', 'course dates'])&#10;        # Write each record, joining multiple dates with a pipe&#10;        for rec in records:&#10;            dates_field = '|'.join(rec['course dates'])&#10;            writer.writerow([rec['course full name'], rec['course code'], dates_field])&#10;&#10;&#10;if __name__ == '__main__':&#10;    import argparse&#10;    parser = argparse.ArgumentParser(description='Parse HTML list info into CSV table')&#10;    parser.add_argument('--input', '-i', default=os.path.join('data', 'raw', 'test', 'temp.html'), help='Path to input HTML file')&#10;    parser.add_argument('--output', '-o', default='courses.csv', help='Path to output CSV file')&#10;    args = parser.parse_args()&#10;    records = parse_html_file(args.input)&#10;    write_csv(records, args.output)&#10;    print(f&quot;Wrote {len(records)} courses to {args.output}&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
