<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/parse_courses_html.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/parse_courses_html.py" />
              <option name="updatedContent" value="import re&#10;import csv&#10;import os&#10;&#10;def parse_html_file(input_path):&#10;    with open(input_path, 'r', encoding='utf-8') as f:&#10;        data = f.read()&#10;    # Remove HTML comment markers to include commented program lists&#10;    data = re.sub(r'&lt;!--|--&gt;', '', data)&#10;    # Pattern to capture each course section starting at &lt;h3&gt; until next &lt;h3&gt; or end&#10;    section_pattern = re.compile(r'&lt;h3 id=&quot;(?P&lt;id&gt;[^&quot;]+)&quot;&gt;(?P&lt;title&gt;.*?)&lt;/h3&gt;(?P&lt;rest&gt;.*?)(?=(&lt;h3|$))', re.DOTALL)&#10;    records = []&#10;    for match in section_pattern.finditer(data):&#10;        title = match.group('title').strip()&#10;        # Extract course full name and code from title&#10;        if title.endswith(')') and '(' in title:&#10;            name_part, code_part = title.rsplit('(', 1)&#10;            course_name = name_part.strip()&#10;            course_code = code_part.rstrip(')').strip()&#10;        else:&#10;            course_name = title&#10;            course_code = ''&#10;        # Find all &lt;li&gt; elements in the rest of the section&#10;        rest = match.group('rest')&#10;        li_pattern = re.compile(r'&lt;li&gt;(.*?)&lt;/li&gt;', re.DOTALL)&#10;        dates_list = [item.strip() for item in li_pattern.findall(rest)]&#10;        records.append({&#10;            'course full name': course_name,&#10;            'course code': course_code,&#10;            'course dates': dates_list&#10;        })&#10;    return records&#10;&#10;&#10;def write_csv(records, output_path):&#10;    # Ensure output directory exists&#10;    os.makedirs(os.path.dirname(output_path), exist_ok=True)&#10;    with open(output_path, 'w', newline='', encoding='utf-8') as csvfile:&#10;        writer = csv.writer(csvfile)&#10;        # Header row&#10;        writer.writerow(['course full name', 'course code', 'course dates'])&#10;        # Write each record, joining multiple dates with a pipe&#10;        for rec in records:&#10;            dates_field = '|'.join(rec['course dates'])&#10;            writer.writerow([rec['course full name'], rec['course code'], dates_field])&#10;&#10;&#10;if __name__ == '__main__':&#10;    import argparse&#10;    parser = argparse.ArgumentParser(description='Parse HTML list info into CSV table')&#10;    parser.add_argument('--input', '-i', default=os.path.join('data', 'raw', 'test', 'temp.html'), help='Path to input HTML file')&#10;    parser.add_argument('--output', '-o', default='courses.csv', help='Path to output CSV file')&#10;    args = parser.parse_args()&#10;    records = parse_html_file(args.input)&#10;    write_csv(records, args.output)&#10;    print(f&quot;Wrote {len(records)} courses to {args.output}&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/integration/test_graph_topology.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/integration/test_graph_topology.py" />
              <option name="originalContent" value="# -*- coding: utf-8 -*-&#10;&quot;&quot;&quot;&#10;@author: LIU Ziyi&#10;@email: lavandejoey@outlook.com&#10;@date: 2025/08/14&#10;@version: 0.11.0&#10;@file: tests/integration/test_graph_topology.py&#10;@description: Run graph topology creation and invocation in CLI.&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;import sys&#10;from unittest.mock import patch&#10;&#10;# Ensure project root is on sys.path&#10;sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))&#10;&#10;from core.graph.topology import create_graph&#10;&#10;&#10;def main():&#10;    # Delete chat_history.db before the test to ensure a clean slate&#10;    db_path = &quot;./chat_history.db&quot;&#10;    if os.path.exists(db_path):&#10;        os.remove(db_path)&#10;&#10;    # Patch graph nodes and answer&#10;    with patch(&quot;core.graph.nodes.query_normaliser.query_normaliser_node&quot;) as mock_query_normaliser_node, \&#10;         patch(&quot;core.graph.nodes.history_loader.history_loader_node&quot;) as mock_history_loader_node, \&#10;         patch(&quot;core.graph.nodes.memory_retriever.memory_retriever_node&quot;) as mock_memory_retriever_node, \&#10;         patch(&quot;core.graph.nodes.retriever_hybrid.retriever_hybrid_node&quot;) as mock_retriever_hybrid_node, \&#10;         patch(&quot;core.graph.nodes.reranker.reranker_node&quot;) as mock_reranker_node, \&#10;         patch(&quot;core.graph.nodes.budget_orchestrator.budget_orchestrator_node&quot;) as mock_budget_orchestrator_node, \&#10;         patch(&quot;core.graph.nodes.generator.generator_node&quot;) as mock_generator_node, \&#10;         patch(&quot;core.graph.topology.answer_node&quot;) as mock_answer_node:&#10;        # Set mock return values&#10;        mock_query_normaliser_node.return_value = {&quot;normalized_query&quot;: &quot;normalized query&quot;}&#10;        mock_history_loader_node.return_value = {&quot;chat_history&quot;: []}&#10;        mock_memory_retriever_node.return_value = {&quot;retrieved_memories&quot;: []}&#10;        mock_retriever_hybrid_node.return_value = {&quot;retrieved_docs&quot;: []}&#10;        mock_reranker_node.return_value = {&quot;reranked_docs&quot;: []}&#10;        mock_budget_orchestrator_node.return_value = {&quot;budget&quot;: {}}&#10;        mock_generator_node.return_value = {&quot;generation&quot;: &quot;generation&quot;}&#10;        mock_answer_node.return_value = {&quot;answer&quot;: &quot;answer&quot;}&#10;&#10;        # Create and invoke graph&#10;        graph = create_graph()&#10;        inputs = {&quot;query&quot;: &quot;test query&quot;, &quot;session_id&quot;: &quot;test_session&quot;}&#10;        result = graph.invoke(inputs)&#10;&#10;        # Check result&#10;        print(&quot;Result answer:&quot;, result.get(&quot;answer&quot;))&#10;        if result.get(&quot;answer&quot;) != &quot;answer&quot;:&#10;            print(&quot;Test failed: expected 'answer'&quot;)&#10;            sys.exit(1)&#10;&#10;    print(&quot;test_graph_topology passed.&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="# -*- coding: utf-8 -*-&#10;&quot;&quot;&quot;&#10;@author: LIU Ziyi&#10;@email: lavandejoey@outlook.com&#10;@date: 2025/08/14&#10;@version: 0.11.0&#10;@file: tests/integration/test_graph_topology.py&#10;@description: Run graph topology creation and invocation in CLI.&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;import sys&#10;from unittest.mock import patch&#10;&#10;# Ensure project root is on sys.path&#10;sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))&#10;&#10;from core.graph.topology import create_graph&#10;&#10;&#10;def main():&#10;    # Delete chat_history.db before the test to ensure a clean slate&#10;    db_path = &quot;./chat_history.db&quot;&#10;    if os.path.exists(db_path):&#10;        os.remove(db_path)&#10;&#10;    # Patch graph nodes and answer&#10;    with patch(&quot;core.graph.nodes.query_normaliser.query_normaliser_node&quot;) as mock_query_normaliser_node, \&#10;         patch(&quot;core.graph.nodes.history_loader.history_loader_node&quot;) as mock_history_loader_node, \&#10;         patch(&quot;core.graph.nodes.memory_retriever.memory_retriever_node&quot;) as mock_memory_retriever_node, \&#10;         patch(&quot;core.graph.nodes.retriever_hybrid.retriever_hybrid_node&quot;) as mock_retriever_hybrid_node, \&#10;         patch(&quot;core.graph.nodes.reranker.reranker_node&quot;) as mock_reranker_node, \&#10;         patch(&quot;core.graph.nodes.budget_orchestrator.budget_orchestrator_node&quot;) as mock_budget_orchestrator_node, \&#10;         patch(&quot;core.graph.nodes.generator.generator_node&quot;) as mock_generator_node, \&#10;         patch(&quot;core.graph.topology.answer_node&quot;) as mock_answer_node:&#10;        # Set mock return values&#10;        mock_query_normaliser_node.return_value = {&quot;normalized_query&quot;: &quot;normalized query&quot;}&#10;        mock_history_loader_node.return_value = {&quot;chat_history&quot;: []}&#10;        mock_memory_retriever_node.return_value = {&quot;retrieved_memories&quot;: []}&#10;        mock_retriever_hybrid_node.return_value = {&quot;retrieved_docs&quot;: []}&#10;        mock_reranker_node.return_value = {&quot;reranked_docs&quot;: []}&#10;        mock_budget_orchestrator_node.return_value = {&quot;budget&quot;: {}}&#10;        mock_generator_node.return_value = {&quot;generation&quot;: &quot;generation&quot;}&#10;        mock_answer_node.return_value = {&quot;answer&quot;: &quot;answer&quot;}&#10;&#10;        # Create and invoke graph&#10;        graph = create_graph()&#10;        inputs = {&quot;query&quot;: &quot;test query&quot;, &quot;session_id&quot;: &quot;test_session&quot;}&#10;        result = graph.invoke(inputs)&#10;&#10;        # Check result&#10;        print(&quot;Result answer:&quot;, result.get(&quot;answer&quot;))&#10;        if result.get(&quot;answer&quot;) != &quot;answer&quot;:&#10;            print(&quot;Test failed: expected 'answer'&quot;)&#10;            sys.exit(1)&#10;&#10;    print(&quot;test_graph_topology passed.&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>