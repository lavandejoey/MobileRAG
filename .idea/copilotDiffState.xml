<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/apps/chat_api/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/chat_api/main.py" />
              <option name="originalContent" value="# -*- coding: utf-8 -*-&#10;&quot;&quot;&quot;&#10;@author: LIU Ziyi&#10;@email: lavandejoey@outlook.com&#10;@date: 2025/08/15&#10;@version: 0.12.0&#10;&quot;&quot;&quot;&#10;from fastapi import FastAPI&#10;from apps.chat_api.routes import chat&#10;&#10;app = FastAPI()&#10;&#10;app.include_router(chat.router, prefix=&quot;/api&quot;)&#10;" />
              <option name="updatedContent" value="# -*- coding: utf-8 -*-&#10;&quot;&quot;&quot;&#10;@author: LIU Ziyi&#10;@email: lavandejoey@outlook.com&#10;@date: 2025/08/15&#10;@version: 0.12.0&#10;&quot;&quot;&quot;&#10;from fastapi import FastAPI&#10;from fastapi.staticfiles import StaticFiles&#10;from apps.chat_api.routes import chat&#10;&#10;app = FastAPI()&#10;&#10;# Include the API router&#10;app.include_router(chat.router, prefix=&quot;/api&quot;)&#10;&#10;# Mount the static files directory of the chat UI&#10;# This allows the backend to serve the frontend's static assets&#10;app.mount(&quot;/&quot;, StaticFiles(directory=&quot;apps/chat_ui/dist&quot;, html=True), name=&quot;static&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/chat_api/routes/chat.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/chat_api/routes/chat.py" />
              <option name="originalContent" value="# -*- coding: utf-8 -*-&#10;&quot;&quot;&quot;&#10;@author: LIU Ziyi&#10;@email: lavandejoey@outlook.com&#10;@date: 2025/08/15&#10;@version: 0.12.0&#10;&quot;&quot;&quot;&#10;from fastapi import APIRouter&#10;from pydantic import BaseModel&#10;from starlette.responses import StreamingResponse&#10;import asyncio&#10;import json&#10;&#10;from core.graph.topology import create_graph&#10;&#10;router = APIRouter()&#10;&#10;class ChatRequest(BaseModel):&#10;    query: str&#10;    session_id: str&#10;&#10;@router.post(&quot;/chat&quot;)&#10;async def chat(request: ChatRequest):&#10;    &quot;&quot;&quot;&#10;    Handles the chat endpoint.&#10;    &quot;&quot;&quot;&#10;    graph = create_graph()&#10;&#10;    async def event_generator():&#10;        try:&#10;            # Use the graph to stream responses&#10;            async for chunk in graph.astream(request.dict()):&#10;                if &quot;answer&quot; in chunk:&#10;                    # Yield the answer chunk as a server-sent event&#10;                    yield f'data: {json.dumps({&quot;answer&quot;: chunk[&quot;answer&quot;]})}\n\n'&#10;                # Add a small delay to allow the client to process the event&#10;                await asyncio.sleep(0.01)&#10;        except asyncio.CancelledError:&#10;            # Handle client disconnection gracefully&#10;            print(&quot;Client disconnected&quot;)&#10;&#10;    # Return a streaming response&#10;    return StreamingResponse(event_generator(), media_type=&quot;text/event-stream&quot;)" />
              <option name="updatedContent" value="# -*- coding: utf-8 -*-&#10;&quot;&quot;&quot;&#10;@author: LIU Ziyi&#10;@email: lavandejoey@outlook.com&#10;@date: 2025/08/15&#10;@version: 0.12.0&#10;&quot;&quot;&quot;&#10;from fastapi import APIRouter&#10;from pydantic import BaseModel&#10;from starlette.responses import StreamingResponse&#10;import asyncio&#10;import json&#10;&#10;from core.graph.topology import create_graph&#10;&#10;router = APIRouter()&#10;&#10;class ChatRequest(BaseModel):&#10;    query: str&#10;    session_id: str&#10;&#10;@router.post(&quot;/chat&quot;)&#10;async def chat(request: ChatRequest):&#10;    &quot;&quot;&quot;&#10;    Handles the chat endpoint.&#10;    &quot;&quot;&quot;&#10;    graph = create_graph()&#10;&#10;    async def event_generator():&#10;        try:&#10;            # Use the graph to stream responses&#10;            async for chunk in graph.astream(request.dict()):&#10;                if &quot;answer&quot; in chunk:&#10;                    answer_payload = chunk[&quot;answer&quot;]&#10;                    # The graph might be nesting the answer in another dict, extract it&#10;                    if isinstance(answer_payload, dict) and &quot;answer&quot; in answer_payload:&#10;                        final_answer = answer_payload[&quot;answer&quot;]&#10;                    else:&#10;                        final_answer = answer_payload&#10;                    # Yield the answer chunk as a server-sent event&#10;                    yield f'data: {json.dumps({&quot;answer&quot;: final_answer})}\n\n'&#10;                elif &quot;evidence&quot; in chunk:&#10;                    # Yield the evidence chunk as a server-sent event&#10;                    yield f'data: {json.dumps({&quot;evidence&quot;: chunk[&quot;evidence&quot;]})}\n\n'&#10;                # Add a small delay to allow the client to process the event&#10;                await asyncio.sleep(0.01)&#10;        except asyncio.CancelledError:&#10;            # Handle client disconnection gracefully&#10;            print(&quot;Client disconnected&quot;)&#10;&#10;    # Return a streaming response&#10;    return StreamingResponse(event_generator(), media_type=&quot;text/event-stream&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/chat_ui/src/App.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/chat_ui/src/App.css" />
              <option name="originalContent" value="/* -*- coding: utf-8 -*-&#10;/**&#10; * @author: LIU Ziyi&#10; * @email: lavandejoey@outlook.com&#10; * @date: 2025/08/15&#10; * @version: 0.12.0&#10; */&#10;.App {&#10;  display: flex;&#10;  flex-direction: column;&#10;  height: 100vh;&#10;  font-family: Arial, sans-serif;&#10;  background-color: #f0f2f5;&#10;}&#10;&#10;.App-header {&#10;  background-color: #282c34;&#10;  padding: 20px;&#10;  color: white;&#10;  text-align: center;&#10;  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;}&#10;&#10;.App-header h1 {&#10;  margin: 0;&#10;}&#10;&#10;.backend-status {&#10;  font-size: 0.9em;&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 5px;&#10;}&#10;&#10;.spinner {&#10;  width: 16px;&#10;  height: 16px;&#10;  border-radius: 50%;&#10;  background-color: white;&#10;  animation: pulse 1.5s infinite ease-in-out;&#10;}&#10;&#10;@keyframes pulse {&#10;  0% {&#10;    transform: scale(0);&#10;    opacity: 0;&#10;  }&#10;  50% {&#10;    opacity: 1;&#10;  }&#10;  100% {&#10;    transform: scale(1);&#10;    opacity: 0;&#10;  }&#10;}&#10;&#10;.chat-main {&#10;  display: flex;&#10;  flex-grow: 1;&#10;}&#10;&#10;.chat-container {&#10;  flex-grow: 1;&#10;  display: flex;&#10;  flex-direction: column;&#10;  padding: 20px;&#10;  overflow-y: auto;&#10;  max-width: 800px; /* Set a max-width */&#10;  width: 100%; /* Allow it to be flexible */&#10;  margin: 20px auto;&#10;  background-color: #fff;&#10;  border-radius: 8px;&#10;  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);&#10;}&#10;&#10;.messages-display {&#10;  flex-grow: 1;&#10;  overflow-y: auto;&#10;  padding: 10px;&#10;  border-bottom: 1px solid #eee;&#10;}&#10;&#10;.message {&#10;  padding: 8px 12px;&#10;  margin-bottom: 10px;&#10;  border-radius: 18px;&#10;  max-width: 70%;&#10;  word-wrap: break-word;&#10;  line-height: 1.5; /* Adjust line spacing */&#10;}&#10;&#10;.message.user {&#10;  background-color: #007bff;&#10;  color: white;&#10;  align-self: flex-end;&#10;  margin-left: auto;&#10;  border-bottom-right-radius: 4px;&#10;  text-align: right;&#10;  width: fit-content;&#10;}&#10;&#10;.message.assistant {&#10;  background-color: #e2e6ea;&#10;  color: #333;&#10;  align-self: flex-start;&#10;  margin-right: auto;&#10;  border-bottom-left-radius: 4px;&#10;  text-align: left;&#10;  /*width: fit-content;*/&#10;}&#10;&#10;.message.assistant.generating {&#10;  /*background-color: #ffc107; !* Yellow for thinking *!*/&#10;  color: #333;&#10;  font-style: italic;&#10;  display: flex;&#10;  align-items: center;&#10;}&#10;&#10;.message.assistant.generating .spinner {&#10;  width: 12px;&#10;  height: 12px;&#10;  background-color: #333;&#10;  margin-left: 8px;&#10;}&#10;&#10;.message-input-form {&#10;  display: flex;&#10;  padding: 10px;&#10;  border-top: 1px solid #eee;&#10;}&#10;&#10;.message-input-form input {&#10;  flex-grow: 1;&#10;  padding: 10px;&#10;  border: 1px solid #ddd;&#10;  border-radius: 20px;&#10;  margin-right: 10px;&#10;  font-size: 16px;&#10;}&#10;&#10;.message-input-form button {&#10;  background-color: #007bff;&#10;  color: white;&#10;  border: none;&#10;  padding: 10px 20px;&#10;  border-radius: 20px;&#10;  cursor: pointer;&#10;  font-size: 16px;&#10;  transition: background-color 0.2s;&#10;}&#10;&#10;.message-input-form button:hover {&#10;  background-color: #0056b3;&#10;}&#10;&#10;.sidebar {&#10;  background-color: #f8f9fa;&#10;  padding: 20px;&#10;  width: 250px;&#10;  border-left: 1px solid #e9ecef;&#10;  overflow-y: auto;&#10;  /* position: fixed; */&#10;  /* right: 0; */&#10;  /* top: 0; */&#10;  /* height: 100%; */&#10;  box-shadow: -2px 0 4px rgba(0, 0, 0, 0.05);&#10;}&#10;&#10;.sidebar h2 {&#10;  color: #333;&#10;  margin-top: 0;&#10;  margin-bottom: 15px;&#10;  font-size: 1.2em;&#10;}&#10;&#10;.sidebar p {&#10;  color: #666;&#10;  font-size: 0.9em;&#10;}&#10;" />
              <option name="updatedContent" value="/* -*- coding: utf-8 -*-&#10;/**&#10; * @author: LIU Ziyi&#10; * @email: lavandejoey@outlook.com&#10; * @date: 2025/08/15&#10; * @version: 0.12.0&#10; */&#10;.App {&#10;  display: flex;&#10;  flex-direction: column;&#10;  height: 100vh;&#10;  font-family: Arial, sans-serif;&#10;  background-color: #f0f2f5;&#10;}&#10;&#10;.App-header {&#10;  background-color: #282c34;&#10;  padding: 20px;&#10;  color: white;&#10;  text-align: center;&#10;  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;}&#10;&#10;.App-header h1 {&#10;  margin: 0;&#10;}&#10;&#10;.backend-status {&#10;  font-size: 0.9em;&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 5px;&#10;}&#10;&#10;.spinner {&#10;  width: 16px;&#10;  height: 16px;&#10;  border-radius: 50%;&#10;  background-color: white;&#10;  animation: pulse 1.5s infinite ease-in-out;&#10;}&#10;&#10;@keyframes pulse {&#10;  0% {&#10;    transform: scale(0);&#10;    opacity: 0;&#10;  }&#10;  50% {&#10;    opacity: 1;&#10;  }&#10;  100% {&#10;    transform: scale(1);&#10;    opacity: 0;&#10;  }&#10;}&#10;&#10;.chat-main {&#10;  display: flex;&#10;  flex-grow: 1;&#10;}&#10;&#10;.chat-container {&#10;  flex-grow: 1;&#10;  display: flex;&#10;  flex-direction: column;&#10;  padding: 20px;&#10;  overflow-y: auto;&#10;  max-width: 800px; /* Set a max-width */&#10;  width: 100%; /* Allow it to be flexible */&#10;  margin: 20px auto;&#10;  background-color: #fff;&#10;  border-radius: 8px;&#10;  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);&#10;}&#10;&#10;.messages-display {&#10;  flex-grow: 1;&#10;  overflow-y: auto;&#10;  padding: 10px;&#10;  border-bottom: 1px solid #eee;&#10;}&#10;&#10;.message {&#10;  padding: 8px 12px;&#10;  margin-bottom: 10px;&#10;  border-radius: 18px;&#10;  max-width: 70%;&#10;  word-wrap: break-word;&#10;  line-height: 1.5; /* Adjust line spacing */&#10;}&#10;&#10;.message.user {&#10;  background-color: #007bff;&#10;  color: white;&#10;  align-self: flex-end;&#10;  margin-left: auto;&#10;  border-bottom-right-radius: 4px;&#10;  text-align: right;&#10;  width: fit-content;&#10;}&#10;&#10;.message.assistant {&#10;  background-color: #e2e6ea;&#10;  color: #333;&#10;  align-self: flex-start;&#10;  margin-right: auto;&#10;  border-bottom-left-radius: 4px;&#10;  text-align: left;&#10;  /*width: fit-content;*/&#10;}&#10;&#10;.generating-spinner-container {&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;  padding: 10px;&#10;}&#10;&#10;.generating-spinner-container .spinner {&#10;  width: 24px;&#10;  height: 24px;&#10;  background-color: #888; /* A medium gray for the spinner */&#10;}&#10;&#10;.message-input-form {&#10;  display: flex;&#10;  padding: 10px;&#10;  border-top: 1px solid #eee;&#10;}&#10;&#10;.message-input-form input {&#10;  flex-grow: 1;&#10;  padding: 10px;&#10;  border: 1px solid #ddd;&#10;  border-radius: 20px;&#10;  margin-right: 10px;&#10;  font-size: 16px;&#10;}&#10;&#10;.message-input-form button {&#10;  background-color: #007bff;&#10;  color: white;&#10;  border: none;&#10;  padding: 10px 20px;&#10;  border-radius: 20px;&#10;  cursor: pointer;&#10;  font-size: 16px;&#10;  transition: background-color 0.2s;&#10;}&#10;&#10;.message-input-form button:hover {&#10;  background-color: #0056b3;&#10;}&#10;&#10;.sidebar {&#10;  background-color: #f8f9fa;&#10;  padding: 20px;&#10;  width: 250px;&#10;  border-left: 1px solid #e9ecef;&#10;  overflow-y: auto;&#10;  /* position: fixed; */&#10;  /* right: 0; */&#10;  /* top: 0; */&#10;  /* height: 100%; */&#10;  box-shadow: -2px 0 4px rgba(0, 0, 0, 0.05);&#10;}&#10;&#10;.sidebar h2 {&#10;  color: #333;&#10;  margin-top: 0;&#10;  margin-bottom: 15px;&#10;  font-size: 1.2em;&#10;}&#10;&#10;.sidebar p {&#10;  color: #666;&#10;  font-size: 0.9em;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/chat_ui/src/App.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/chat_ui/src/App.jsx" />
              <option name="originalContent" value="// -*- coding: utf-8 -*-&#10;/**&#10; * @author: LIU Ziyi&#10; * @email: lavandejoey@outlook.com&#10; * @date: 2025/08/15&#10; * @version: 0.12.0&#10; */&#10;import React, { useState, useEffect, useRef } from 'react';&#10;import './App.css';&#10;&#10;function App() {&#10;  const [messages, setMessages] = useState([]);&#10;  const [input, setInput] = useState('');&#10;  const [sessionId, setSessionId] = useState('test_session'); // Default session ID&#10;  const [evidenceList, setEvidenceList] = useState([]);&#10;  const [memoryList, setMemoryList] = useState([]);&#10;  const [isGenerating, setIsGenerating] = useState(false); // New state for generation status&#10;  const [backendStatus, setBackendStatus] = useState('checking'); // 'online', 'offline', 'checking'&#10;  const messagesEndRef = useRef(null);&#10;&#10;  const scrollToBottom = () =&gt; {&#10;    messagesEndRef.current?.scrollIntoView({ behavior: &quot;smooth&quot; });&#10;  };&#10;&#10;  // Effect to scroll to bottom on new messages&#10;  useEffect(() =&gt; {&#10;    scrollToBottom();&#10;  }, [messages]);&#10;&#10;  // Effect to check backend status periodically&#10;  useEffect(() =&gt; {&#10;    const checkStatus = async () =&gt; {&#10;      try {&#10;        const response = await fetch('/api/status');&#10;        if (response.ok) {&#10;          const data = await response.json();&#10;          setBackendStatus(data.status === 'online' ? 'online' : 'offline');&#10;        } else {&#10;          setBackendStatus('offline');&#10;        }&#10;      } catch (error) {&#10;        setBackendStatus('offline');&#10;      }&#10;    };&#10;&#10;    checkStatus(); // Check immediately on mount&#10;    const intervalId = setInterval(checkStatus, 5000); // Check every 5 seconds&#10;&#10;    return () =&gt; clearInterval(intervalId); // Cleanup on unmount&#10;  }, []);&#10;&#10;  const handleSendMessage = async (e) =&gt; {&#10;    e.preventDefault();&#10;    if (input.trim() === '') return;&#10;&#10;    const userMessage = { sender: 'user', text: input };&#10;    setMessages((prevMessages) =&gt; [...prevMessages, userMessage]);&#10;    setInput('');&#10;    setEvidenceList([]); // Clear previous evidence&#10;    setIsGenerating(true); // Set generating status to true&#10;&#10;    let currentAssistantMessage = '';&#10;    const updateAssistantMessage = (text) =&gt; {&#10;      setMessages((prevMessages) =&gt; {&#10;        const lastMessage = prevMessages[prevMessages.length - 1];&#10;        if (lastMessage &amp;&amp; lastMessage.sender === 'assistant') {&#10;          return [...prevMessages.slice(0, -1), { ...lastMessage, text: text }];&#10;        } else {&#10;          return [...prevMessages, { sender: 'assistant', text: text }];&#10;        }&#10;      });&#10;    };&#10;&#10;    try {&#10;      const response = await fetch('/api/chat', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;        },&#10;        body: JSON.stringify({ query: input, session_id: sessionId }),&#10;      });&#10;&#10;      const reader = response.body.getReader();&#10;      const decoder = new TextDecoder();&#10;&#10;      while (true) {&#10;        const { done, value } = await reader.read();&#10;        if (done) break;&#10;        const chunk = decoder.decode(value, { stream: true });&#10;        &#10;        // Process each line as a separate SSE event&#10;        chunk.split('\n').forEach(line =&gt; {&#10;          if (line.startsWith('data:')) {&#10;            const jsonString = line.substring(5).trim();&#10;            if (jsonString) {&#10;              try {&#10;                const data = JSON.parse(jsonString);&#10;                if (data.answer) {&#10;                  currentAssistantMessage += data.answer;&#10;                  updateAssistantMessage(currentAssistantMessage);&#10;                } else if (data.evidence) {&#10;                  setEvidenceList(prev =&gt; [...prev, data.evidence]);&#10;                } else if (data.memory) {&#10;                  setMemoryList(prev =&gt; [...prev, data.memory]);&#10;                }&#10;              } catch (error) {&#10;                console.error(&quot;Error parsing SSE JSON:&quot;, error, &quot;JSON string:&quot;, jsonString);&#10;              }&#10;            }&#10;          }&#10;        });&#10;      }&#10;    } catch (error) {&#10;      console.error('Error sending message:', error);&#10;      updateAssistantMessage('Error: Could not connect to the server.');&#10;    } finally {&#10;      setIsGenerating(false); // Set generating status to false when done or error&#10;    }&#10;  };&#10;&#10;  const getStatusColor = () =&gt; {&#10;    switch (backendStatus) {&#10;      case 'online': return 'green';&#10;      case 'offline': return 'red';&#10;      case 'checking': return 'orange';&#10;      default: return 'gray';&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;App&quot;&gt;&#10;      &lt;header className=&quot;App-header&quot;&gt;&#10;        &lt;h1&gt;MobileRAG&lt;/h1&gt;&#10;        &lt;div className=&quot;backend-status&quot;&gt;&#10;          &lt;span style={{ color: getStatusColor() }}&gt;●&lt;/span&gt; {backendStatus}&#10;        &lt;/div&gt;&#10;      &lt;/header&gt;&#10;      &lt;div className=&quot;chat-main&quot;&gt;&#10;        &lt;div className=&quot;chat-container&quot;&gt;&#10;          &lt;div className=&quot;messages-display&quot;&gt;&#10;            {messages.map((msg, index) =&gt; (&#10;              &lt;div key={index} className={`message ${msg.sender}`}&gt;&#10;                {msg.text}&#10;              &lt;/div&gt;&#10;            ))}&#10;            {isGenerating &amp;&amp; (&#10;              &lt;div className=&quot;message assistant generating&quot;&gt;&#10;                Thinking &lt;div className=&quot;spinner&quot;&gt;&lt;/div&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;            &lt;div ref={messagesEndRef} /&gt;&#10;          &lt;/div&gt;&#10;          &lt;form onSubmit={handleSendMessage} className=&quot;message-input-form&quot;&gt;&#10;            &lt;input&#10;              type=&quot;text&quot;&#10;              value={input}&#10;              onChange={(e) =&gt; setInput(e.target.value)}&#10;              placeholder=&quot;Type your message...&quot;&#10;              disabled={isGenerating}&#10;            /&gt;&#10;            &lt;button type=&quot;submit&quot; disabled={!input.trim() || isGenerating}&gt;Send&lt;/button&gt;&#10;          &lt;/form&gt;&#10;        &lt;/div&gt;&#10;        &lt;div className=&quot;sidebar&quot;&gt;&#10;          &lt;h2&gt;Evidence&lt;/h2&gt;&#10;          {evidenceList.length === 0 ? (&#10;            &lt;p&gt;No evidence found for this query.&lt;/p&gt;&#10;          ) : (&#10;            &lt;ul&gt;&#10;              {evidenceList.map((ev, index) =&gt; (&#10;                &lt;li key={index}&gt;{JSON.stringify(ev)}&lt;/li&gt; // Display raw JSON for now&#10;              ))}&#10;            &lt;/ul&gt;&#10;          )}&#10;          &lt;h2&gt;Memory&lt;/h2&gt;&#10;          {memoryList.length === 0 ? (&#10;            &lt;p&gt;No memory items found.&lt;/p&gt;&#10;          ) : (&#10;            &lt;ul&gt;&#10;              {memoryList.map((mem, index) =&gt; (&#10;                &lt;li key={index}&gt;{JSON.stringify(mem)}&lt;/li&gt; // Display raw JSON for now&#10;                            ))}&#10;            &lt;/ul&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default App;&#10;" />
              <option name="updatedContent" value="// -*- coding: utf-8 -*-&#10;/**&#10; * @author: LIU Ziyi&#10; * @email: lavandejoey@outlook.com&#10; * @date: 2025/08/15&#10; * @version: 0.12.0&#10; */&#10;import React, { useState, useEffect, useRef } from 'react';&#10;import './App.css';&#10;&#10;function App() {&#10;  const [messages, setMessages] = useState([]);&#10;  const [input, setInput] = useState('');&#10;  const [sessionId, setSessionId] = useState('test_session'); // Default session ID&#10;  const [evidenceList, setEvidenceList] = useState([]);&#10;  const [memoryList, setMemoryList] = useState([]);&#10;  const [isGenerating, setIsGenerating] = useState(false); // New state for generation status&#10;  const [backendStatus, setBackendStatus] = useState('checking'); // 'online', 'offline', 'checking'&#10;  const messagesEndRef = useRef(null);&#10;&#10;  const scrollToBottom = () =&gt; {&#10;    messagesEndRef.current?.scrollIntoView({ behavior: &quot;smooth&quot; });&#10;  };&#10;&#10;  // Effect to scroll to bottom on new messages&#10;  useEffect(() =&gt; {&#10;    scrollToBottom();&#10;  }, [messages]);&#10;&#10;  // Effect to check backend status periodically&#10;  useEffect(() =&gt; {&#10;    const checkStatus = async () =&gt; {&#10;      try {&#10;        const response = await fetch('/api/status');&#10;        if (response.ok) {&#10;          const data = await response.json();&#10;          setBackendStatus(data.status === 'online' ? 'online' : 'offline');&#10;        } else {&#10;          setBackendStatus('offline');&#10;        }&#10;      } catch (error) {&#10;        setBackendStatus('offline');&#10;      }&#10;    };&#10;&#10;    checkStatus(); // Check immediately on mount&#10;    const intervalId = setInterval(checkStatus, 5000); // Check every 5 seconds&#10;&#10;    return () =&gt; clearInterval(intervalId); // Cleanup on unmount&#10;  }, []);&#10;&#10;  const handleSendMessage = async (e) =&gt; {&#10;    e.preventDefault();&#10;    if (input.trim() === '') return;&#10;&#10;    const userMessage = { sender: 'user', text: input };&#10;    setMessages((prevMessages) =&gt; [...prevMessages, userMessage]);&#10;    setInput('');&#10;    setEvidenceList([]); // Clear previous evidence&#10;    setIsGenerating(true); // Set generating status to true&#10;&#10;    let currentAssistantMessage = '';&#10;    const updateAssistantMessage = (text) =&gt; {&#10;      setMessages((prevMessages) =&gt; {&#10;        const lastMessage = prevMessages[prevMessages.length - 1];&#10;        if (lastMessage &amp;&amp; lastMessage.sender === 'assistant') {&#10;          return [...prevMessages.slice(0, -1), { ...lastMessage, text: text }];&#10;        } else {&#10;          return [...prevMessages, { sender: 'assistant', text: text }];&#10;        }&#10;      });&#10;    };&#10;&#10;    try {&#10;      const response = await fetch('/api/chat', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;        },&#10;        body: JSON.stringify({ query: input, session_id: sessionId }),&#10;      });&#10;&#10;      const reader = response.body.getReader();&#10;      const decoder = new TextDecoder();&#10;&#10;      while (true) {&#10;        const { done, value } = await reader.read();&#10;        if (done) break;&#10;        const chunk = decoder.decode(value, { stream: true });&#10;        &#10;        // Process each line as a separate SSE event&#10;        chunk.split('\n').forEach(line =&gt; {&#10;          if (line.startsWith('data:')) {&#10;            const jsonString = line.substring(5).trim();&#10;            if (jsonString) {&#10;              try {&#10;                const data = JSON.parse(jsonString);&#10;                if (data.answer) {&#10;                  currentAssistantMessage += data.answer;&#10;                  updateAssistantMessage(currentAssistantMessage);&#10;                } else if (data.evidence) {&#10;                  setEvidenceList(prev =&gt; [...prev, data.evidence]);&#10;                } else if (data.memory) {&#10;                  setMemoryList(prev =&gt; [...prev, data.memory]);&#10;                }&#10;              } catch (error) {&#10;                console.error(&quot;Error parsing SSE JSON:&quot;, error, &quot;JSON string:&quot;, jsonString);&#10;              }&#10;            }&#10;          }&#10;        });&#10;      }&#10;    } catch (error) {&#10;      console.error('Error sending message:', error);&#10;      updateAssistantMessage('Error: Could not connect to the server.');&#10;    } finally {&#10;      setIsGenerating(false); // Set generating status to false when done or error&#10;    }&#10;  };&#10;&#10;  const getStatusColor = () =&gt; {&#10;    switch (backendStatus) {&#10;      case 'online': return 'green';&#10;      case 'offline': return 'red';&#10;      case 'checking': return 'orange';&#10;      default: return 'gray';&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;App&quot;&gt;&#10;      &lt;header className=&quot;App-header&quot;&gt;&#10;        &lt;h1&gt;MobileRAG&lt;/h1&gt;&#10;        &lt;div className=&quot;backend-status&quot;&gt;&#10;          &lt;span style={{ color: getStatusColor() }}&gt;●&lt;/span&gt; {backendStatus}&#10;        &lt;/div&gt;&#10;      &lt;/header&gt;&#10;      &lt;div className=&quot;chat-main&quot;&gt;&#10;        &lt;div className=&quot;chat-container&quot;&gt;&#10;          &lt;div className=&quot;messages-display&quot;&gt;&#10;            {messages.map((msg, index) =&gt; (&#10;              &lt;div key={index} className={`message ${msg.sender}`}&gt;&#10;                {msg.text}&#10;              &lt;/div&gt;&#10;            ))}&#10;            {isGenerating &amp;&amp; (&#10;              &lt;div className=&quot;generating-spinner-container&quot;&gt;&#10;                &lt;div className=&quot;spinner&quot;&gt;&lt;/div&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;            &lt;div ref={messagesEndRef} /&gt;&#10;          &lt;/div&gt;&#10;          &lt;form onSubmit={handleSendMessage} className=&quot;message-input-form&quot;&gt;&#10;            &lt;input&#10;              type=&quot;text&quot;&#10;              value={input}&#10;              onChange={(e) =&gt; setInput(e.target.value)}&#10;              placeholder=&quot;Type your message...&quot;&#10;              disabled={isGenerating}&#10;            /&gt;&#10;            &lt;button type=&quot;submit&quot; disabled={!input.trim() || isGenerating}&gt;Send&lt;/button&gt;&#10;          &lt;/form&gt;&#10;        &lt;/div&gt;&#10;        &lt;div className=&quot;sidebar&quot;&gt;&#10;          &lt;h2&gt;Evidence&lt;/h2&gt;&#10;          {evidenceList.length === 0 ? (&#10;            &lt;p&gt;No evidence found for this query.&lt;/p&gt;&#10;          ) : (&#10;            &lt;ul&gt;&#10;              {evidenceList.map((ev, index) =&gt; (&#10;                &lt;li key={index}&gt;{JSON.stringify(ev)}&lt;/li&gt; // Display raw JSON for now&#10;              ))}&#10;            &lt;/ul&gt;&#10;          )}&#10;          &lt;h2&gt;Memory&lt;/h2&gt;&#10;          {memoryList.length === 0 ? (&#10;            &lt;p&gt;No memory items found.&lt;/p&gt;&#10;          ) : (&#10;            &lt;ul&gt;&#10;              {memoryList.map((mem, index) =&gt; (&#10;                &lt;li key={index}&gt;{JSON.stringify(mem)}&lt;/li&gt; // Display raw JSON for now&#10;                            ))}&#10;            &lt;/ul&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default App;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/smoke_cli.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/smoke_cli.py" />
              <option name="originalContent" value="# -*- coding: utf-8 -*-&#10;&quot;&quot;&quot;&#10;@author: LIU Ziyi&#10;@email: lavandejoey@outlook.com&#10;@date: 2025/08/15&#10;@version: 0.12.0&#10;&quot;&quot;&quot;&#10;import argparse&#10;import requests&#10;import json&#10;&#10;def chat_cli(query: str, session_id: str):&#10;    url = &quot;http://localhost:8000/api/chat&quot;&#10;    payload = {&quot;query&quot;: query, &quot;session_id&quot;: session_id}&#10;    headers = {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;&#10;    print(f&quot;Sending query: '{query}' to session '{session_id}'&quot;)&#10;    try:&#10;        with requests.post(url, json=payload, headers=headers, stream=True) as response:&#10;            response.raise_for_status()  # Raise an exception for HTTP errors&#10;            print(&quot;Assistant: &quot;, end=&quot;&quot;)&#10;            for chunk in response.iter_content(chunk_size=None):&#10;                if chunk:&#10;                    decoded_chunk = chunk.decode('utf-8')&#10;                    # Split by lines and process each SSE event&#10;                    for line in decoded_chunk.splitlines():&#10;                        if line.startswith(&quot;data:&quot;):&#10;                            json_str = line[len(&quot;data:&quot;):].strip()&#10;                            if json_str:&#10;                                try:&#10;                                    data = json.loads(json_str)&#10;                                    print(f&quot;Raw data: {data}\n&quot;)&#10;                                    print(data.get(&quot;answer&quot;, &quot;&quot;), end='', flush=True)&#10;                                except json.JSONDecodeError:&#10;                                    # Ignore chunks that are not valid JSON&#10;                                    pass&#10;            print(&quot;\n&quot;)  # Newline after stream ends&#10;    except requests.exceptions.RequestException as e:&#10;        print(f&quot;Error connecting to API: {e}&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    parser = argparse.ArgumentParser(description=&quot;Smoke test CLI for MobileRAG API.&quot;)&#10;    subparsers = parser.add_subparsers(dest=&quot;command&quot;, help=&quot;Available commands&quot;)&#10;&#10;    # Chat command&#10;    chat_parser = subparsers.add_parser(&quot;chat&quot;, help=&quot;Send a chat message.&quot;)&#10;    chat_parser.add_argument(&quot;--q&quot;, type=str, required=True, help=&quot;Query string.&quot;)&#10;    chat_parser.add_argument(&quot;--session&quot;, type=str, default=&quot;default_session&quot;, help=&quot;Session ID.&quot;)&#10;&#10;    args = parser.parse_args()&#10;&#10;    if args.command == &quot;chat&quot;:&#10;        chat_cli(args.q, args.session)&#10;    else:&#10;        parser.print_help()&#10;" />
              <option name="updatedContent" value="# -*- coding: utf-8 -*-&#10;&quot;&quot;&quot;&#10;@author: LIU Ziyi&#10;@email: lavandejoey@outlook.com&#10;@date: 2025/08/15&#10;@version: 0.12.0&#10;&quot;&quot;&quot;&#10;import argparse&#10;import requests&#10;import json&#10;&#10;def chat_cli(query: str, session_id: str):&#10;    url = &quot;http://localhost:8000/api/chat&quot;&#10;    payload = {&quot;query&quot;: query, &quot;session_id&quot;: session_id}&#10;    headers = {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;&#10;    print(f&quot;Sending query: '{query}' to session '{session_id}'&quot;)&#10;    try:&#10;        with requests.post(url, json=payload, headers=headers, stream=True) as response:&#10;            response.raise_for_status()  # Raise an exception for HTTP errors&#10;            print(&quot;Assistant: &quot;, end=&quot;&quot;)&#10;            full_answer = []&#10;            evidence_list = []&#10;            for chunk in response.iter_content(chunk_size=None):&#10;                if chunk:&#10;                    decoded_chunk = chunk.decode('utf-8')&#10;                    for line in decoded_chunk.splitlines():&#10;                        if line.startswith(&quot;data:&quot;):&#10;                            json_str = line[len(&quot;data:&quot;):].strip()&#10;                            if json_str:&#10;                                try:&#10;                                    data = json.loads(json_str)&#10;                                    if &quot;answer&quot; in data:&#10;                                        answer_part = data.get(&quot;answer&quot;, &quot;&quot;)&#10;                                        print(answer_part, end='', flush=True)&#10;                                        full_answer.append(answer_part)&#10;                                    elif &quot;evidence&quot; in data:&#10;                                        evidence_list.append(data[&quot;evidence&quot;])&#10;                                except json.JSONDecodeError:&#10;                                    pass  # Ignore invalid JSON&#10;&#10;            print(&quot;\n&quot;)  # Newline after stream ends&#10;&#10;            if evidence_list:&#10;                print(&quot;\n--- Evidence ---&quot;)&#10;                for i, evidence in enumerate(evidence_list, 1):&#10;                    print(f&quot;{i}. {evidence}&quot;)&#10;                print(&quot;----------------\n&quot;)&#10;&#10;    except requests.exceptions.RequestException as e:&#10;        print(f&quot;Error connecting to API: {e}&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    parser = argparse.ArgumentParser(description=&quot;Smoke test CLI for MobileRAG API.&quot;)&#10;    subparsers = parser.add_subparsers(dest=&quot;command&quot;, help=&quot;Available commands&quot;)&#10;&#10;    # Chat command&#10;    chat_parser = subparsers.add_parser(&quot;chat&quot;, help=&quot;Send a chat message.&quot;)&#10;    chat_parser.add_argument(&quot;--q&quot;, type=str, required=True, help=&quot;Query string.&quot;)&#10;    chat_parser.add_argument(&quot;--session&quot;, type=str, default=&quot;default_session&quot;, help=&quot;Session ID.&quot;)&#10;&#10;    args = parser.parse_args()&#10;&#10;    if args.command == &quot;chat&quot;:&#10;        chat_cli(args.q, args.session)&#10;    else:&#10;        parser.print_help()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/parse_courses_html.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/parse_courses_html.py" />
              <option name="updatedContent" value="import re&#10;import csv&#10;import os&#10;&#10;def parse_html_file(input_path):&#10;    with open(input_path, 'r', encoding='utf-8') as f:&#10;        data = f.read()&#10;    # Remove HTML comment markers to include commented program lists&#10;    data = re.sub(r'&lt;!--|--&gt;', '', data)&#10;    # Pattern to capture each course section starting at &lt;h3&gt; until next &lt;h3&gt; or end&#10;    section_pattern = re.compile(r'&lt;h3 id=&quot;(?P&lt;id&gt;[^&quot;]+)&quot;&gt;(?P&lt;title&gt;.*?)&lt;/h3&gt;(?P&lt;rest&gt;.*?)(?=(&lt;h3|$))', re.DOTALL)&#10;    records = []&#10;    for match in section_pattern.finditer(data):&#10;        title = match.group('title').strip()&#10;        # Extract course full name and code from title&#10;        if title.endswith(')') and '(' in title:&#10;            name_part, code_part = title.rsplit('(', 1)&#10;            course_name = name_part.strip()&#10;            course_code = code_part.rstrip(')').strip()&#10;        else:&#10;            course_name = title&#10;            course_code = ''&#10;        # Find all &lt;li&gt; elements in the rest of the section&#10;        rest = match.group('rest')&#10;        li_pattern = re.compile(r'&lt;li&gt;(.*?)&lt;/li&gt;', re.DOTALL)&#10;        dates_list = [item.strip() for item in li_pattern.findall(rest)]&#10;        records.append({&#10;            'course full name': course_name,&#10;            'course code': course_code,&#10;            'course dates': dates_list&#10;        })&#10;    return records&#10;&#10;&#10;def write_csv(records, output_path):&#10;    # Ensure output directory exists&#10;    os.makedirs(os.path.dirname(output_path), exist_ok=True)&#10;    with open(output_path, 'w', newline='', encoding='utf-8') as csvfile:&#10;        writer = csv.writer(csvfile)&#10;        # Header row&#10;        writer.writerow(['course full name', 'course code', 'course dates'])&#10;        # Write each record, joining multiple dates with a pipe&#10;        for rec in records:&#10;            dates_field = '|'.join(rec['course dates'])&#10;            writer.writerow([rec['course full name'], rec['course code'], dates_field])&#10;&#10;&#10;if __name__ == '__main__':&#10;    import argparse&#10;    parser = argparse.ArgumentParser(description='Parse HTML list info into CSV table')&#10;    parser.add_argument('--input', '-i', default=os.path.join('data', 'raw', 'test', 'temp.html'), help='Path to input HTML file')&#10;    parser.add_argument('--output', '-o', default='courses.csv', help='Path to output CSV file')&#10;    args = parser.parse_args()&#10;    records = parse_html_file(args.input)&#10;    write_csv(records, args.output)&#10;    print(f&quot;Wrote {len(records)} courses to {args.output}&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
